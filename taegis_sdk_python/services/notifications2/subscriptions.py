"""Notifications2 Subscription."""

# pylint: disable=no-member, unused-argument, too-many-locals, duplicate-code, wildcard-import, unused-wildcard-import, cyclic-import


# Autogenerated
# DO NOT MODIFY

from __future__ import annotations

import logging
from typing import TYPE_CHECKING, Any, Dict, List, Optional, Tuple, Union

from taegis_sdk_python import GraphQLNoRowsInResultSetError
from taegis_sdk_python._consts import TaegisEnum
from taegis_sdk_python.services.notifications2.types import *
from taegis_sdk_python.utils import (
    build_output_string,
    parse_union_result,
    prepare_input,
)

if TYPE_CHECKING:  # pragma: no cover
    from taegis_sdk_python.services.notifications2 import Notifications2Service

log = logging.getLogger(__name__)


class TaegisSDKNotifications2Subscription:
    """Taegis Notifications2 Subscription operations."""

    def __init__(self, service: Notifications2Service):
        self.service = service

    def notifications(
        self, arguments: Optional[NotificationSubscriptionArguments] = None
    ) -> List[NotificationSubscription]:
        """Notifications Subscriptions are used to get an event when a new notification is created for the calling user.
        A websocket connection is required to make this graphql call. Once the websocket is opened and the subscription started,
        any new notification created for the calling user will be sent to the client.

        If NotificationSubscriptionArguments are provided, the subscription will also return a list of existing notifications based on the arguments provided.

        Multiple subscription calls with different arguments can be made needing to create a new websocket connection in order to paginate over the existing notifications.
        As a client is paginating, new notifications will continue to be sent to the client as they are created outside of the pagination calls.

        Filters set in the notification subscription arguments are not applied to newly created notifications at this time..
        """
        endpoint = "notifications"

        result = self.service.execute_subscription(
            endpoint=endpoint,
            variables={
                "arguments": prepare_input(arguments),
            },
            output=build_output_string(
                NotificationSubscription,
                exclude_deprecated_output=self.service.exclude_deprecated_output,
            ),
        )
        if any(r.get(endpoint) for r in result):
            return NotificationSubscription.schema().load(
                [r.get(endpoint, {}) or {} for r in result], many=True
            )
        raise GraphQLNoRowsInResultSetError("for subscription notifications")
